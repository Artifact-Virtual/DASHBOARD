import React, { useEffect, useRef } from 'react';

// Single-file, GH Pages–friendly, no external asset imports.
// Upgrades:
//  - Parallax XYZ layer stack reacting to mouse with depth mapping.
//  - 3D non-rotating "artifact core" with pointer tilt only.
//  - Glyphy, ultra-light typographic system using Lexend (200/300) + Montserrat.
//  - Accessible, reduced-motion-safe; no runtime state hooks.
//  - Self-tests kept & expanded; no external images.

export default function Hero() {
  const orbRef = useRef(null);
  const layersRef = useRef([]);
  const rafRef = useRef(0);
  const mouseRef = useRef({ x: 0, y: 0 });

  // Compute tilt for the core (no perpetual rotation)
  useEffect(() => {
    const onMove = (e) => {
      mouseRef.current.x = e.clientX;
      mouseRef.current.y = e.clientY;
    };
    window.addEventListener('mousemove', onMove, { passive: true });
    return () => window.removeEventListener('mousemove', onMove);
  }, []);

  // Animation loop to apply both tilt and parallax (rAF to coalesce)
  useEffect(() => {
    let running = true;

    const loop = () => {
      if (!running) return;
      const { innerWidth: w = 1, innerHeight: h = 1 } = window;
      const { x, y } = mouseRef.current;

      // Core tilt
      if (orbRef.current) {
        const { rx, ry } = computeTilt(x, y, w, h, 18);
        orbRef.current.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg)`;
      }

      // Parallax on each layer
      const nx = (x / w - 0.5) * 2; // [-1,1]
      const ny = (y / h - 0.5) * 2; // [-1,1]
      for (const el of layersRef.current) {
        if (!el) continue;
        const depth = Number(el.dataset.depth || 0);
        // Smaller movement for deeper layers
        const dx = -nx * depth * 10; // px
        const dy = -ny * depth * 10; // px
        const dz = depth * 40;       // px into screen
        el.style.transform = `translate3d(${dx}px, ${dy}px, ${-dz}px)`;
      }

      rafRef.current = requestAnimationFrame(loop);
    };

    // Respect reduced motion
    const mq = window.matchMedia('(prefers-reduced-motion: reduce)');
    if (mq.matches) return; // do not animate

    rafRef.current = requestAnimationFrame(loop);
    return () => {
      running = false;
      cancelAnimationFrame(rafRef.current);
    };
  }, []);

  // Helper to attach refs for layers
  const layerRef = (i) => (el) => (layersRef.current[i] = el);

  return (
    <div className="hero">
      {/* Inline CSS so the sandbox/bundler doesn't choke on separate CSS files */}
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Lexend:wght@200;300;700;900&family=Montserrat:wght@200;300;700;900&display=swap');

        :root {
          --bg-0: #0a0505;
          --bg-1: #120909;
          --bg-2: #1b0f0f;
          --accent: #ff5a00;   /* dark orange */
          --accent-2: #b51a00; /* maroon-ish */
          --glass: rgba(255,255,255,0.06);
          --glass-2: rgba(255,255,255,0.02);
          --ink: #f2ebe8;
        }
        * { box-sizing: border-box; }
        .hero {
          height: 100vh;
          background: radial-gradient(120% 100% at 50% 10%, var(--bg-2) 0%, var(--bg-1) 40%, var(--bg-0) 100%);
          color: var(--ink);
          overflow: hidden;
          font-family: 'Lexend', 'Montserrat', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Noto Sans', sans-serif;
          letter-spacing: .01em;
        }
        .hero-header {
          padding: 14px 18px;
          display: flex;
          align-items: center;
          justify-content: space-between;
          text-transform: uppercase;
          font-size: 11px;
          letter-spacing: .25em;
        }
        .nav { display: flex; gap: 24px; opacity: .85; }
        .nav a { color: var(--ink); text-decoration: none; transition: transform .15s ease, color .2s ease; }
        .nav a:hover { transform: scale(1.06); color: var(--accent); }
        .av-logo { width: 64px; height: 28px; }

        .hero-content {
          position: relative;
          display: grid;
          place-items: center;
          height: calc(100% - 60px);
          text-align: center;
          perspective: 1200px;
        }

        /* --- Imaginative 3D hero stack w/ parallax --- */
        .core-stage {
          position: relative;
          width: min(70vw, 640px);
          height: min(70vw, 640px);
          transform-style: preserve-3d;
        }
        .layer { position: absolute; inset: 0; will-change: transform; }

        /* Back grid (deep space) */
        .grid {
          background-image:
            radial-gradient(rgba(255,90,0,.06) 0 2px, transparent 2px 100%),
            linear-gradient(to bottom, rgba(255,255,255,.04), rgba(0,0,0,0));
          background-size: 22px 22px, 100% 100%;
          border-radius: 36px;
          mask-image: radial-gradient(120% 120% at 50% 42%, #000 52%, transparent 70%);
        }

        /* Glow halo */
        .halo { filter: blur(12px); }
        .halo::before {
          content: ""; position: absolute; inset: -24px; border-radius: 50%;
          background: radial-gradient(60% 60% at 50% 40%, rgba(255,90,0,.35), rgba(255,90,0,.06) 60%, transparent 70%);
        }

        /* Wireframe cage */
        .cage { display: grid; place-items: center; opacity: .65; }
        .cage svg g { filter: drop-shadow(0 0 10px rgba(255,90,0,.15)); }

        /* Glass monoliths */
        .monolith-a, .monolith-b {
          inset: 10%; border-radius: 28px; border: 1px solid rgba(255,255,255,.09);
          background: linear-gradient(135deg, var(--glass), var(--glass-2));
          backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
        }
        .monolith-b { inset: 18%; background: linear-gradient(45deg, rgba(255,90,0,.09), rgba(255,90,0,.02)); }

        /* Scanlines + noise */
        .overlay { pointer-events: none; border-radius: 36px; overflow: hidden; }
        .overlay::before {
          content: ""; position: absolute; inset: 0; opacity: .08;
          background: repeating-linear-gradient(to bottom, rgba(255,255,255,.7) 0 1px, transparent 1px 3px);
        }
        .overlay::after {
          content: ""; position: absolute; inset: 0; opacity: .1;
          background-image: radial-gradient(rgba(255,255,255,.5) 1px, transparent 1px);
          background-size: 18px 18px;
        }

        /* Artifact core (no auto-rotate) */
        .core {
          display: grid; place-items: center; border-radius: 36px;
          background:
            radial-gradient(120% 120% at 50% 35%, rgba(255,140,66,0.18) 0%, rgba(134,40,0,0.18) 35%, rgba(10,6,6,0) 60%),
            radial-gradient(circle at 50% 50%, rgba(255,255,255,0.08) 0%, rgba(0,0,0,0) 60%);
          transition: transform .2s ease-out;
        }
        .glyph {
          font-size: clamp(44px, 9vw, 92px);
          font-weight: 900;
          letter-spacing: .08em;
          background: linear-gradient(45deg, var(--accent), var(--accent-2));
          -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
          text-shadow: 0 0 18px rgba(255, 80, 0, 0.55);
        }

        /* Orbits */
        .orbits path { stroke: rgba(255,255,255,.18); fill: none; }
        .nodes circle { fill: rgba(255,90,0,.9); }

        .hero-title { font-size: clamp(32px, 6vw, 56px); margin-top: 18px; font-weight: 300; letter-spacing: .02em; }
        .hero-subtitle { font-size: 1.15rem; opacity: .85; font-weight: 200; }
        .cta { margin-top: 22px; }
        .btn {
          display: inline-block; padding: 12px 22px; border-radius: 12px;
          background: #5b1f05; color: #fff; text-decoration: none;
          transition: transform .12s ease, box-shadow .2s ease, background .2s ease;
        }
        .btn:hover { transform: translateY(-1px); background: #6c2607; box-shadow: 0 0 24px var(--accent); }

        /* backdrop wash */
        .wash { position: absolute; inset: 0; pointer-events: none; opacity: .6;
          background: radial-gradient(ellipse at top, rgba(255,102,0,.08) 0%, transparent 60%);
        }
      `}</style>

      <header className="hero-header">
        <nav className="nav">
          <a href="#">Discord</a>
          <a href="#">X.com</a>
          <a href="#">Docs</a>
          <a href="#">Blog</a>
        </nav>
        {/* 2-letter AV monogram (inline SVG) */}
        <svg className="av-logo" viewBox="0 0 120 40" role="img" aria-label="AV">
          <g fill="none" stroke="#fff" strokeWidth="3" strokeLinejoin="bevel">
            <path d="M6 34 L18 6 L30 34" />
            <path d="M10 26 H26" />
            <path d="M58 6 L70 34 L82 6" />
          </g>
          <rect x="92" y="28" width="22" height="2" fill="#fff" opacity="0.85" />
        </svg>
        <a className="btn" href="#">Launch App</a>
      </header>

      {/* Soft backdrop wash */}
      <div className="wash" />

      <div className="hero-content">
        {/* 3D Parallax Stage */}
        <div className="core-stage">
          {/* Depth order: far (0.8) -> near (0.2) */}
          <div ref={layerRef(0)} data-depth="0.8" className="layer grid" />
          <div ref={layerRef(1)} data-depth="0.6" className="layer halo" />

          {/* Wireframe cage */}
          <div ref={layerRef(2)} data-depth="0.5" className="layer cage" aria-hidden>
            <svg viewBox="0 0 200 200" width="92%" height="92%">
              <g fill="none" stroke="rgba(255,102,0,0.35)" strokeWidth="1.6">
                <polygon points="100,6 158,28 194,86 194,144 158,172 100,194 42,172 6,144 6,86 42,28" />
                <circle cx="100" cy="100" r="70" />
                <circle cx="100" cy="100" r="40" />
                <line x1="6" y1="86" x2="194" y2="86" />
                <line x1="6" y1="144" x2="194" y2="144" />
                <line x1="42" y1="28" x2="158" y2="172" />
                <line x1="158" y1="28" x2="42" y2="172" />
              </g>
            </svg>
          </div>

          {/* Glass monoliths */}
          <div ref={layerRef(3)} data-depth="0.35" className="layer monolith-a" />
          <div ref={layerRef(4)} data-depth="0.3" className="layer monolith-b" />

          {/* Scanlines + dot noise */}
          <div ref={layerRef(5)} data-depth="0.25" className="layer overlay" />

          {/* Artifact core (interactive tilt) */}
          <div ref={orbRef} className="layer core" data-depth="0.2" aria-label="Artifact Core">
            <div className="glyph" title="ARCx core">⟟</div>
          </div>

          {/* Subtle orbits */}
          <div ref={layerRef(6)} data-depth="0.15" className="layer orbits" aria-hidden>
            <svg viewBox="0 0 560 560" width="100%" height="100%">
              <g className="orbit">
                <path d="M80,280 a200,100 0 1,0 400,0 a200,100 0 1,0 -400,0" />
                <path d="M120,280 a160,50 0 1,0 320,0 a160,50 0 1,0 -320,0" />
                <path d="M160,280 a120,40 0 1,0 240,0 a120,40 0 1,0 -240,0" />
              </g>
              <g className="nodes">
                <circle cx="80" cy="280" r="3" />
                <circle cx="480" cy="280" r="3" />
                <circle cx="280" cy="160" r="3" />
              </g>
            </svg>
          </div>
        </div>

        <h1 className="hero-title">Artifact Virtual</h1>
        <p className="hero-subtitle">Immersive, intelligent, and autonomous systems</p>
        <div className="cta"><a className="btn" href="#">Enter</a></div>
      </div>
    </div>
  );
}

// ===== Pure helpers & tests (no DOM/sandbox-safe) =====
export function computeTilt(clientX, clientY, width, height, maxDeg = 18) {
  if (!width || !height) return { rx: 0, ry: 0 };
  const nx = (clientX / width - 0.5) * 2; // [-1, 1]
  const ny = (clientY / height - 0.5) * 2; // [-1, 1]
  const clamp = (v, m) => Math.max(-m, Math.min(m, v));
  return { rx: clamp(-ny * maxDeg, maxDeg), ry: clamp(nx * maxDeg, maxDeg) };
}

(function selfTests() {
  try {
    const eq = (a, b, eps = 1e-9) => Math.abs(a - b) < eps;

    // Existing tests (unchanged)
    let { rx, ry } = computeTilt(50, 50, 100, 100, 20);
    if (!eq(rx, 0) || !eq(ry, 0)) throw new Error('center tilt should be 0/0');

    ({ rx, ry } = computeTilt(0, 0, 100, 100, 10));
    if (!eq(rx, 10) || !eq(ry, -10)) throw new Error('top-left should clamp to 10/-10');

    ({ rx, ry } = computeTilt(100, 100, 100, 100, 15));
    if (!eq(rx, -15) || !eq(ry, 15)) throw new Error('bottom-right should be -15/15');

    ({ rx, ry } = computeTilt(150, 50, 300, 100, 12));
    if (!eq(rx, 0) || !eq(ry, 0)) throw new Error('midpoint of non-square should be 0/0');

    // Additional tests
    ({ rx, ry } = computeTilt(300, 50, 300, 100, 18));
    if (!eq(rx, 0) || !eq(ry, 18)) throw new Error('right edge should be +max ry');

    ({ rx, ry } = computeTilt(0, 100, 300, 100, 12));
    if (!eq(rx, -12) || !eq(ry, -12)) throw new Error('bottom-left should be -max/+ -max');

    ({ rx, ry } = computeTilt(0, 0, 0, 0, 99));
    if (!eq(rx, 0) || !eq(ry, 0)) throw new Error('zero dims should return 0/0');

  } catch (err) {
    console.error('Hero computeTilt self-tests failed:', err);
  }
})();
